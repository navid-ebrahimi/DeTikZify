# # -*- coding: utf-8 -*-
# """final-generating-images (16).ipynb

# Automatically generated by Colab.

# Original file is located at
#     https://colab.research.google.com/drive/1P8HdiSLV3r-PlRpwWTaJ9vzYwJX91_D5
# """

# # !pip install datasets -q

from datasets import load_dataset

from huggingface_hub import login
login(token="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")

"""# **Section 2**"""

# !wget https://mirror.ctan.org/systems/texlive/tlnet/install-tl-unx.tar.gz

# !zcat < ./install-tl-unx.tar.gz | tar xf -

# !perl ./install-tl-20241112/install-tl --no-interaction

import os
os.environ['PATH'] += ':/usr/local/texlive/2024/bin/x86_64-linux'

# !ls -l /usr/local/texlive/2024/bin/

# !pip install fitz -q

# !pip install PyMuPDF -q

import os
import subprocess
import tempfile
import shutil
import fitz
from PIL import Image
import PIL
import numpy as np
from PIL import ImageChops
import nltk
from nltk.corpus import wordnet

"""# **Ghost**"""

# !sudo apt-get install -y ghostscript
# !sudo apt install -y poppler-utils
# !pip install nltk -q

import re
import random
import nltk
from nltk.corpus import wordnet

nltk.download('averaged_perceptron_tagger')
nltk.download('averaged_perceptron_tagger_eng')
nltk.download('wordnet')

predefined_colors = ['red', 'blue', 'green', 'echodrk', 'yellow', 'purple', 'mymauve', 'orange', 'cyan', 'magenta', 'brown', 'black', 'camdrk', 'olivegreen', 'darkgray', 'lightgray', 'camdrk', 'violet', 'teal']
defined_colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'cyan', 'brown', 'black']

def random_color():
    """Generate a random color in the format 'red', 'blue', etc. or 'color!percentage'."""
    base_color = random.choice(defined_colors)
    percentage = random.randint(0, 100)
    return f"{base_color}!{percentage}"

def random_angle_change(angle):
    """Adjust the angle randomly by up to +/- 2 units."""
    change = random.randint(-2, 2)
    return angle + change

def random_text():
    """Generate a random placeholder text for nodes."""
    words = ['Data Structures', 'Algorithms', 'Graph Theory', 'Machine Learning', 'Complexity Theory', 'Optimization']
    return random.choice(words)

def replace_colors(tikz_code):
    """Replace all colors in the TikZ code with random colors."""
    # Define a regex pattern for matching colors
    color_pattern = r'(concept color=)([a-z]+!?[0-9]*)'

    # Replace each color with a random color
    new_tikz_code = re.sub(color_pattern, lambda m: m.group(1) + random_color(), tikz_code)

    return new_tikz_code

known_colors = ['red', 'blue', 'green', 'echodrk', 'yellow', 'purple', 'orange', 'black', 'white', 'gray', 'pink', 'olivegreen', 'camdrk']

def replace_colors_in_node_style(match):
    """Replace standalone color names within node styles."""
    style_content = match.group(1)

    # Pattern to find standalone color names (avoiding key=value pairs)
    color_pattern = r'\b(?<!color=)\b(?![a-z]+=)[a-zA-Z]+(?=\b|,)'

    def replace_color(m):
        color = m.group(0)
        if color in predefined_colors:
            return random.choice(defined_colors)
        return color

    # Replace known color names with random predefined colors
    new_style_content = re.sub(color_pattern, replace_color, style_content)

    return f"[{new_style_content}]"

def modify_node_colors(tikz_code):
    """Modify colors within \node styles and other commands."""
    # Pattern to find \node commands and capture the styles inside []
    node_style_pattern = r'\[([^\]]*?)\]'

    # Replace colors within node styles
    new_tikz_code = re.sub(node_style_pattern, replace_colors_in_node_style, tikz_code)

    return new_tikz_code

def adjust_angles(tikz_code):
    """Randomly adjust angles in the TikZ code by a maximum of 2 units."""
    # Define a regex pattern for matching sibling angles
    angle_pattern = r'(sibling angle=)(\d+)'

    # Replace each angle with a slightly adjusted one
    new_tikz_code = re.sub(angle_pattern, lambda m: m.group(1) + str(random_angle_change(int(m.group(2)))), tikz_code)

    return new_tikz_code

def replace_texts(tikz_code):
    """Replace texts in the TikZ picture (excluding TikZ structure commands) with random text."""
    # Define a regex pattern for matching text inside node { ... }
    text_pattern = r'node \{([^}]*)\}'

    # Replace each text inside node with random text
    new_tikz_code = re.sub(text_pattern, lambda m: f'node {{{random_text()}}}', tikz_code)

    return new_tikz_code

def random_thickness():
    """Randomly select one of the thickness types."""
    thickness_types = ['thin', 'thick']
    return random.choice(thickness_types)

def random_amplitude_change(amplitude):
    """Adjust the amplitude by a maximum of +/- 3 units."""
    change = random.uniform(0, 0.3)  # Adjust up to 3 units in amplitude (for example, 0.3mm)
    new_amplitude = round(amplitude + change, 2)
    return new_amplitude

def random_segment_length_change(segment_length):
    """Adjust the segment length by a maximum of +/- 3 units."""
    change = random.uniform(0, 3)  # Adjust up to 3mm in segment length
    new_segment_length = round(segment_length + change, 2)
    return new_segment_length

def replace_thickness(tikz_code):
    """Replace thickness in the TikZ code with random thickness values."""
    # Define a regex pattern for matching thickness
    thickness_pattern = r'\b(thin|semithick|thick|very thick)\b'

    # Replace each thickness with a random thickness
    new_tikz_code = re.sub(thickness_pattern, lambda m: random_thickness(), tikz_code)

    return new_tikz_code

def adjust_amplitude(tikz_code):
    """Adjust the amplitude values in the TikZ code."""
    amplitude_pattern = r'amplitude=([0-9]*\.?[0-9]+)(mm)'

    # Replace each amplitude value with a slightly adjusted one
    new_tikz_code = re.sub(amplitude_pattern, lambda m: f'amplitude={random_amplitude_change(float(m.group(1)))}mm', tikz_code)

    return new_tikz_code

def adjust_segment_length(tikz_code):
    """Adjust the segment length values in the TikZ code."""
    segment_length_pattern = r'segment length=([0-9]*\.?[0-9]+)(mm)'

    # Replace each segment length value with a slightly adjusted one
    new_tikz_code = re.sub(segment_length_pattern, lambda m: f'segment length={random_segment_length_change(float(m.group(1)))}mm', tikz_code)

    return new_tikz_code

# List of patterns to exclude from removal
exclude_patterns = [
    r'\\begin\{tikzpicture\}', r'\\end\{tikzpicture\}', r'\\begin\{scope\}', r'\\end\{scope\}', r'\\node', r'\\coordinate',
    r'\\path', r'\\matrix', r'\\foreach', r'\\scope', r'\\endscope', r'\\usetikzlibrary', r'\\pgfdeclarelayer',
    r'\\pgfonlayer', r'\\definecolor', r'\\usepackage', r'\\documentclass', r'\\DeclareMathOperator', r'\\def', r'\\tikzset'
]

def is_excluded(line):
    """Check if a line contains any of the excluded patterns."""
    for pattern in exclude_patterns:
        if re.search(pattern, line):
            return True
    return False

def is_foreach_block(tikz_code_lines, index):
    """Check if a command is part of a \foreach block."""
    # Look backward from the current line to see if we're inside a \foreach block
    foreach_pattern = r'\\foreach'
    for i in range(index, -1, -1):
        if re.search(foreach_pattern, tikz_code_lines[i]):
            return True
        # Stop looking if we encounter a closing bracket or end of scope
        if re.search(r'\\end|\}', tikz_code_lines[i]):
            break
    return False

def remove_random_draw_path_tags(tikz_code, removal_probability=0.5):
    """
    Remove random occurrences of \draw and \path tags in the TikZ code based on the given probability,
    except for those immediately after a \foreach. Also handle node references.
    """
    lines = tikz_code.splitlines()
    modified_lines = []
    skip_next_draw_or_path = False
    defined_nodes = set()
    removed_nodes = set()

    draw_path_pattern = r'\\(draw|path)\s*(\[[^]]*\])?\s*([^-][^;]*?);'
    node_definition_pattern = r'node\s*\[([^\]]*)\]\s*\(([^)]+)\)'
    node_reference_pattern = r'\(([^)]+)\)'

    for line in lines:
        if '\\foreach' in line:
            skip_next_draw_or_path = True
            modified_lines.append(line)
            continue

        if re.search(draw_path_pattern, line):
            if skip_next_draw_or_path:
                modified_lines.append(line)
                skip_next_draw_or_path = False
                # Add any defined nodes to the set
                for node_match in re.finditer(node_definition_pattern, line):
                    defined_nodes.add(node_match.group(2))
            else:
                if random.random() < removal_probability:
                    # If removing, check for any node definitions and add to removed_nodes
                    for node_match in re.finditer(node_definition_pattern, line):
                        removed_nodes.add(node_match.group(2))
                else:
                    modified_lines.append(line)
                    # Add any defined nodes to the set
                    for node_match in re.finditer(node_definition_pattern, line):
                        defined_nodes.add(node_match.group(2))
        else:
            # For lines without \draw or \path, check for node references
            modified_line = line
            for node_match in re.finditer(node_reference_pattern, line):
                node_name = node_match.group(1)
                if node_name in removed_nodes:
                    # Replace references to removed nodes with a placeholder
                    modified_line = modified_line.replace(f'({node_name})', '(0,0)')
            modified_lines.append(modified_line)

    modified_tikz_code = '\n'.join(modified_lines)
    return modified_tikz_code


def modify_node_expressions(tikz_code):
    """
    Modify expressions inside \node elements in TikZ code with predefined replacements.

    Args:
    - tikz_code (str): The original TikZ code as a string.

    Returns:
    - str: The modified TikZ code with updated node expressions.
    """

    # Define the regex pattern to capture content inside \node[...] {<content>} blocks
    node_pattern = re.compile(r'(\\node\s*(?:\[.*?\])?\s*(?:\(.*?\))?\s*\{.*?\})', re.DOTALL)

    # Predefined replacements dictionary (modify as needed)
    replacement_list = [
        '\\cos',    # Example replacement 1
        '\\sin', # Example replacement 2
        '\\tan', # Example replacement 3
        '\\log'    # Example replacement 4
    ]

    # Function to replace math expressions inside $...$
    def replace_math_content(match):
        node_content = match.group(0)

        # Find all $...$ expressions inside the node content, handling line breaks and multiline properly
        math_pattern = re.compile(r'\$.*?\$', re.DOTALL)
        math_expressions = math_pattern.findall(node_content)

        # Replace each math expression with elements from the replacement list, one by one
        for i, expr in enumerate(math_expressions):
            # Cycle through the replacement list
            replacement = replacement_list[i % len(replacement_list)]
            node_content = node_content.replace(expr, f"${replacement}$")

        return node_content

    # Apply the replacement function to each \node element
    modified_tikz = node_pattern.sub(replace_math_content, tikz_code)

    return modified_tikz

line_styles = ['dashed', 'dotted']

def random_style_change(current_style):
    """Randomly change between line styles 'thick', 'solid', 'dashed', 'dotted'."""
    # Remove the current style from the list and choose a new one
    new_styles = [style for style in line_styles if style != current_style]
    return random.choice(new_styles)

def adjust_positioning(tikz_code):
    """Add random values to 'above', 'below', and 'minimum width'."""
    # Pattern to find 'above=Xem', 'below=Xem', and 'minimum width=Xem'
    positioning_pattern = r'(above|below)=([0-9]*\.?[0-9]+)(em|mm)|(\bminimum width=)([0-9]*\.?[0-9]+)(em|mm)'

    # Function to adjust values by adding a random small value
    def adjust_value(match):
        if match.group(1):  # 'above=Xem' or 'below=Xem'
            original_value = float(match.group(2))
            adjustment = random.uniform(0, 1)
            new_value = round(original_value + adjustment, 2)
            return f"{match.group(1)}={new_value}{match.group(3)}"
        elif match.group(4):
            original_value = float(match.group(5))
            adjustment = random.uniform(0, 1)
            new_value = round(original_value + adjustment, 2)
            return f"minimum width={new_value}{match.group(6)}"

    # Replace the values in the TikZ code by adjusting them
    new_tikz_code = re.sub(positioning_pattern, adjust_value, tikz_code)

    return new_tikz_code

def replace_line_styles(tikz_code):
    """Replace line styles ('thick', 'solid', 'dashed', 'dotted') with each other randomly."""
    # Define a regex pattern to match the line styles
    style_pattern = r'\b(solid|dashed|dotted)\b'

    # Replace each line style with a random new one
    new_tikz_code = re.sub(style_pattern, lambda m: random_style_change(m.group(0)), tikz_code)

    return new_tikz_code

def random_addition_to_value(value, max_change=1):
    """Add a random number to the given value."""
    change = random.uniform(-max_change, max_change)  # Random change between -1 and 1
    new_value = round(float(value) + change, 2)  # Add random change to the value and round to 2 decimal places
    return new_value

def modify_right_width_height(tikz_code):
    """Modify the values of right=, minimum width=, and minimum height= in the TikZ code."""
    # Pattern to match right=, minimum width=, and minimum height= values
    pattern = r'(right|minimum width|minimum height)=([0-9]*\.?[0-9]+)([a-zA-Z]*)'

    def modify_value(match):
        # Extract parameter, value, and unit (if any)
        param = match.group(1)
        value = match.group(2)
        unit = match.group(3)  # Could be 'em', 'cm', etc.

        # Add a random number to the extracted value
        new_value = random_addition_to_value(value)

        # Return the modified string
        return f'{param}={new_value}{unit}'

    # Apply the modification to the entire TikZ code
    new_tikz_code = re.sub(pattern, modify_value, tikz_code)

    return new_tikz_code


def random_adjustment(value, max_change=1, integer=False):
    """Adjust the value by a random number within the range -max_change to +max_change."""
    try:
        if integer:
            # Random integer change for range-based loops
            change = random.randint(-max_change, max_change)
            new_value = int(value.strip()) + change
        else:
            # Random float change for list-based loops
            change = random.uniform(-max_change, max_change)
            new_value = round(float(value.strip()), 2) + change
        return new_value
    except ValueError:
        return value  # Return value unchanged if there's an issue

def modify_foreach_bands(tikz_code):
    """Modify the bands in \foreach loops in the TikZ code."""
    range_pattern = r'\\foreach\s+\\(\w+)\s+in\s+\{([-0-9.,\s]+)\}'

    def modify_band(match):
        loop_var = match.group(1)  # Capture the variable (e.g., \i, \j)
        band = match.group(2).strip()

        if '...' in band:  # Handle range-based {...,...,...} case
            # Split into start, ..., and end
            range_parts = band.split('...')
            start_value = range_parts[0].strip().replace(',', '')  # Clean and remove commas
            end_value = range_parts[1].strip().replace(',', '')  # Clean and remove commas

            # Adjust end value with integer
            new_end_value = random_adjustment(end_value, integer=True)

            return f'\\foreach \\{loop_var} in {{{start_value},...,{new_end_value}}}'

        else:  # Handle list-based {-1.5, -0.5, 0.5, 1.5} case
            elements = band.split(',')

            # Adjust each element randomly (as float)
            new_elements = [str(random_adjustment(e.strip(), integer=True)) for e in elements]

            return f'\\foreach \\{loop_var} in {{{", ".join(new_elements)}}}'

    # Apply the modification to all \foreach loops
    new_tikz_code = re.sub(range_pattern, modify_band, tikz_code)

    return new_tikz_code

def replace_colors_in_draw_command(tikz_code):
    """Replace colors in the \draw commands such as fill=gray!50 or draw=red."""
    # Regex to match `fill=color!percent` or `draw=color!percent` inside \draw commands
    color_pattern = r'(fill|draw)=([a-z]+!?[0-9]*)'

    # Replace with random colors
    new_tikz_code = re.sub(color_pattern, lambda m: f"{m.group(1)}={random_color()}", tikz_code)

    return new_tikz_code

def adjust_draw_coordinates(tikz_code):
    """Adjust numbers inside parentheses in \draw commands by adding a random value between 0 and 0.25."""
    # Regex pattern to find numbers inside parentheses after \draw
    coordinate_pattern = r'\((-?\d+\.?\d*),(-?\d+\.?\d*)\)'

    # Function to add a small random value to the coordinates
    def adjust_coordinates(match):
        x = float(match.group(1))
        y = float(match.group(2))
        # Add a random number between 0 and 0.25 to both x and y
        new_x = round(x + random.uniform(0, 0.25), 2)
        new_y = round(y + random.uniform(0, 0.25), 2)
        return f"({new_x},{new_y})"

    # Apply the adjustment to all coordinates in the TikZ code
    new_tikz_code = re.sub(coordinate_pattern, adjust_coordinates, tikz_code)

    return new_tikz_code

# Define a random list of replacement words
replacement_words = ["Transformed", "Projected", "Latent", "Reduced", "Embedded", "Representation", "Feature space", "Vector space"]

def replace_draw_node_text(tikz_code):
    """Replace text in \draw nodes with random words, while keeping math expressions unchanged."""
    # Regex pattern to find text inside \draw nodes after 'node' keyword
    # We look for text inside curly braces after the node part, but not math expressions (e.g., ${...}$)
    node_text_pattern = r'node\s*\[.*?\]\s*\{([^$]*?)\}'

    # Function to replace the found text with a random word
    def replace_text(match):
        original_text = match.group(1)
        # Choose a random word from the replacement list
        new_text = random.choice(replacement_words)
        return f"node{{{new_text}}}"

    # Apply the replacement to all matching parts of the TikZ code
    new_tikz_code = re.sub(node_text_pattern, replace_text, tikz_code)

    return new_tikz_code

random_expressions = [
    r'$\Sigma$',
    r'$\Phi(x)$',
]

def replace_expressions_in_tikz(tikz_code):
    """Replace expressions inside $...$ in TikZ code with random expressions."""
    # Regex pattern to find expressions in the form of $...$
    expression_pattern = r'\$.*?\$'

    # Function to replace found expression with a random expression
    def replace_expression(match):
        return random.choice(random_expressions)

    # Apply the replacement
    new_tikz_code = re.sub(expression_pattern, replace_expression, tikz_code)

    return new_tikz_code

def add_random_to_node_distance(tikz_code, min_value=0, max_value=2):
    # Find the line with 'node distance'
    pattern = r'node distance=(\d+\.?\d*)cm'

    # Function to replace the matched node distance value with a new value
    def replace_node_distance(match):
        original_distance = float(match.group(1))
        random_value = random.uniform(min_value, max_value)
        new_distance = original_distance + random_value
        return f'node distance={new_distance:.2f}cm'

    # Substitute the pattern with the new value
    modified_tikz_code = re.sub(pattern, replace_node_distance, tikz_code)

    return modified_tikz_code

def replace_addplot_colors(tikz_code):
    """
    Replace colors in the \addplot commands such as pattern color=blue with a random color.
    """
    # Regex to match `pattern color=color` inside \addplot commands
    addplot_color_pattern = r'(pattern color=)([a-z]+!?[0-9]*)'

    # Replace with random colors
    new_tikz_code = re.sub(addplot_color_pattern, lambda m: f"{m.group(1)}{random_color()}", tikz_code)

    return new_tikz_code

def replace_fill_shade_colors(tikz_code):
    """
    Replace colors in the \fill and \shade commands.
    """
    # Regex to match color in \fill[...] and \shade[...] patterns
    fill_pattern = r'(\\fill\[)([a-z]+!?[0-9]*)'
    shade_pattern = r'(\\shade\[.*?)([a-z]+!?[0-9]*)(.*?)([a-z]+!?[0-9]*)'

    # Replace colors in \fill command
    new_tikz_code = re.sub(fill_pattern, lambda m: f"{m.group(1)}{random_color()}", tikz_code)

    # Replace colors in \shade command
    new_tikz_code = re.sub(shade_pattern, lambda m: f"{m.group(1)}{random_color()}{m.group(3)}{random_color()}", new_tikz_code)

    return new_tikz_code

def random_adjust(value):
    return value + random.uniform(0, 0.75)

def replace_coordinates(tikz_code):
    """
    Find and modify coordinates by adding a random value (max 1 unit) to each.
    """
    # Regex to match coordinate tuples (e.g., (-6.4, 4, 0))
    coord_pattern = r'\(([-+]?\d*\.?\d+),([-+]?\d*\.?\d+),([-+]?\d*\.?\d+)\)'

    # Replace function to adjust each coordinate value
    def adjust_coordinates(match):
        x = float(match.group(1))
        y = float(match.group(2))
        z = float(match.group(3))

        # Add a random value up to 1 unit to each coordinate
        x_new = random_adjust(x)
        y_new = random_adjust(y)
        z_new = random_adjust(z)

        # Return the new coordinates in the same format
        return f"({x_new:.2f},{y_new:.2f},{z_new:.2f})"

    # Apply the regex and adjust coordinates
    new_tikz_code = re.sub(coord_pattern, adjust_coordinates, tikz_code)

    return new_tikz_code


def find_draw_or_path_commands(tikz_code):
    """Find all \draw and \path commands in the TikZ code."""
    # Regex to match both \draw and \path commands with coordinate-like expressions
    draw_or_path_pattern = r'(\\(draw|path)\s*(\[[^\]]*\])?\s*(\([^)]*\)[^;]*?);)'

    # Find all matches
    matches = list(re.finditer(draw_or_path_pattern, tikz_code))

    return matches

def has_coordinates(command):
    """Check if the given command contains valid 2D or 3D coordinates."""
    coord_2d_pattern = r'\((-?\d+\.?\d*),(-?\d+\.?\d*)\)'
    coord_3d_pattern = r'\((-?\d+\.?\d*),(-?\d+\.?\d*),(-?\d+\.?\d*)\)'

    # Return True if either 2D or 3D coordinate pattern is found
    return bool(re.search(coord_2d_pattern, command)) or bool(re.search(coord_3d_pattern, command))

def apply_random_coordinate_changes(tikz_code):
    """Apply coordinate changes to 2 randomly selected draw or path commands."""
    commands = find_draw_or_path_commands(tikz_code)

    # Filter out commands that don't contain coordinates
    commands_with_coords = [cmd for cmd in commands if has_coordinates(cmd.group(0))]

    # If there are fewer than 2 commands with coordinates, adjust all available ones
    num_commands_to_adjust = min(2, len(commands_with_coords))

    if num_commands_to_adjust == 0:
        # print("No commands with valid coordinates found.")
        return tikz_code

    # Randomly select two commands to adjust
    selected_commands = random.sample(commands_with_coords, num_commands_to_adjust)

    for match in selected_commands:
        command = match.group(0)

        # Randomly choose which coordinate adjustment function to apply
        if random.choice([True, False]):
            new_command = replace_coordinates(command)  # Apply 3D coordinate adjustment
        else:
            new_command = adjust_draw_coordinates(command)  # Apply 2D coordinate adjustment

        # Replace the old command with the new one in the TikZ code
        tikz_code = tikz_code.replace(command, new_command)

    return tikz_code

def modify_3d_code(tikz_code):
    # Regex pattern to match arc segments in the format (x:y:z[optional unit])
    # This pattern will capture 'arc (x:y:z)' regardless of the unit (cm, mm, etc.)
    pattern = r"arc\s*\((\d+):(\d+):([\d\.]+)([a-z]*)\)"

    # Counter for how many arcs have been modified
    modification_count = 0
    max_modifications = 2  # Limit to only 2 modifications

    # Function to modify the matched arc segment
    def modify_arc(match):
        nonlocal modification_count

        if modification_count >= max_modifications:
            # If we already modified 2 arcs, return the match unmodified
            return match.group(0)

        x = match.group(1)  # First angle
        y = match.group(2)  # Second angle
        z = float(match.group(3))  # Radius (third value)
        unit = match.group(4)  # Unit (e.g., cm, mm, or empty string)

        # Modify z by a random value between -2 and 2
        z_modified = z + random.uniform(-2, 2)

        # Ensure z doesn't go below 0
        z_modified = max(0, z_modified)

        # Increment the counter after modifying
        modification_count += 1

        # Return the modified arc with updated z value, keeping the original unit
        return f"arc ({x}:{y}:{z_modified:.2f}{unit})"

    # Use re.sub to replace all arc segments with modified versions, but only modify 2 of them
    modified_tikz_code = re.sub(pattern, modify_arc, tikz_code)

    return modified_tikz_code

def auto_modify_text_in_tikz(tikz_code, modification_probability=1):
    """
    Automatically modify text content in TikZ code.

    :param tikz_code: The original TikZ code as a string.
    :param modification_probability: Probability of modifying each word (default: 0.3).
    :return: Modified TikZ code with automatically changed text content.
    """
    def modify_word(word):
        # Check if the word is a noun or adjective
        pos = nltk.pos_tag([word])[0][1]
        if pos.startswith('NN') or pos.startswith('JJ'):
            synsets = wordnet.synsets(word)
            if synsets:
                # Get all lemmas from all synsets
                lemmas = [lemma for synset in synsets for lemma in synset.lemmas()]
                if lemmas:
                    # Choose a random lemma and return its name
                    return random.choice(lemmas).name().replace('_', ' ')
        return word

    def process_text(match):
        text = match.group(1)
        words = text.split()
        modified_words = [modify_word(word) if random.random() < modification_probability else word for word in words]
        return ' '.join(modified_words)

    # Pattern to match text content in TikZ nodes and labels
    pattern = r'(?<!\\)(?:\\node|\b(?:node|label))\s*(?:\[[^\]]*\])?\s*(?:\([^)]*\))?\s*{([^}]*)}'

    # Replace text content while preserving TikZ structure
    modified_code = re.sub(pattern, lambda m: m.group(0).replace(m.group(1), process_text(m)), tikz_code)

    return modified_code

def main(tikz_code, flag=True):
    # tikz_code = sample_input = dataset['train'][2881]['code']

#     if not re.search(r'\\usetikzlibrary\s*\{shapes\.geometric\}', tikz_code):
#             # Add the library before any TikZ environment
#             tikz_code = re.sub(r'\\begin\{tikzpicture\}', r'\\usetikzlibrary {shapes.geometric}\n\\begin{tikzpicture}', tikz_code)

    # Replace colors in the TikZ code
    tikz_code_with_new_colors = replace_colors(tikz_code)

    # Adjust angles in the TikZ code
    tikz_code_with_adjusted_angles = adjust_angles(tikz_code_with_new_colors)

    # Replace texts in the TikZ code
    # tikz_code_with_random_texts = replace_texts(tikz_code_with_adjusted_angles)

    tikz_code_with_random_thickness = replace_thickness(tikz_code_with_adjusted_angles)

    # Adjust amplitude in the TikZ code
    tikz_code_with_adjusted_amplitude = adjust_amplitude(tikz_code_with_random_thickness)

    # Adjust segment length in the TikZ code
    modified_tikz_code = adjust_segment_length(tikz_code_with_adjusted_amplitude)

    if flag:
        modified_tikz_code = remove_random_draw_path_tags(modified_tikz_code, removal_probability=0.2)

    modified_tikz_code = modify_node_expressions(modified_tikz_code)

    modified_tikz_code = modify_node_colors(modified_tikz_code)

    modified_tikz_code = adjust_positioning(modified_tikz_code)

    # 2. Replace line styles
    modified_tikz_code = replace_line_styles(modified_tikz_code)

    modified_tikz_code = modify_right_width_height(modified_tikz_code)

    # modified_tikz_code = modify_foreach_bands(modified_tikz_code)

    modified_tikz_code = replace_colors_in_draw_command(modified_tikz_code)

    # modified_tikz_code = adjust_draw_coordinates(modified_tikz_code)

    # modified_tikz_code = replace_expressions_in_tikz(modified_tikz_code)

    modified_tikz_code = add_random_to_node_distance(modified_tikz_code, min_value=0.5, max_value=0.75)

    modified_tikz_code = replace_addplot_colors(modified_tikz_code)

    modified_tikz_code = replace_fill_shade_colors(modified_tikz_code)

    # modified_tikz_code = replace_coordinates(modified_tikz_code)

    modified_tikz_code = apply_random_coordinate_changes(modified_tikz_code)

    modified_tikz_code = modify_3d_code(modified_tikz_code)

    modified_tikz_code = auto_modify_text_in_tikz(modified_tikz_code)
    # Output the new code
    return modified_tikz_code

# !pip install tqdm -q
# !sudo apt-get install -y texlive-latex-extra

# !python3 -m nltk.downloader wordnet
# !unzip /usr/share/nltk_data/corpora/wordnet.zip -d /usr/share/nltk_data/corpora/

def add_documentclass_if_missing(tikz_code):
    # Check if documentclass exists
    if r"\documentclass" not in tikz_code:
        # Add only the documentclass
        documentclass = r"\documentclass[crop, tikz]\n"
        # Return the code with added documentclass at the beginning
        return documentclass + tikz_code
    else:        # If documentclass exists, return the code as is
        return tikz_code


import os
import json
from datasets import load_dataset
import matplotlib.pyplot as plt
from tqdm import tqdm
import multiprocessing as mp
import shutil
from math import ceil
import tempfile
from datetime import datetime
import io
import threading
from queue import Queue
import fitz
import subprocess
from concurrent.futures import ThreadPoolExecutor
import time
import pandas as pd
import pyarrow as pa
import pyarrow.parquet as pq
from datetime import datetime
import base64
import sys
from datasets import DatasetDict

class IOBuffer:
    """Thread-safe buffer for I/O operations"""
    def __init__(self):
        self._lock = threading.Lock()
        self._buffer = {}

    def write(self, key, data):
        with self._lock:
            self._buffer[key] = data

    def flush_to_disk(self, output_dir):
        """Bulk write buffered data to disk"""
        with self._lock:
            for key, data in self._buffer.items():
                filepath = os.path.join(output_dir, f"{key}.png")
                data.save(filepath)
            self._buffer.clear()

def tikz2png_buffered(tikz_code, output_figure_name, process_id, io_buffer, timeout_seconds=90):
    """Memory-optimized version of tikz2png that uses buffers instead of immediate disk writes"""
    temp_dir = f'/dev/shm/process_{process_id}_{output_figure_name}'  # Use RAM disk if available

    if not os.path.exists(temp_dir):
        os.makedirs(temp_dir, exist_ok=True)

    try:
        # Use StringIO for text operations
        tex_content = tikz_code.replace(r'\begin{document}',
                                      r"""\begin{document}
                                      \pagenumbering{gobble}""")

        tex_file = os.path.join(temp_dir, 'temp.tex')
        with open(tex_file, 'w', buffering=8192) as f:  # Use buffered writing
            f.write(tex_content)
        # Run pdflatex with optimized parameters
        process = subprocess.Popen(
            ['/usr/local/texlive/2024/bin/x86_64-linux/pdflatex',
             '-interaction=nonstopmode',
             '-halt-on-error',
#              '-shell-escape',  # Enable shell escape
             tex_file],
            cwd=temp_dir,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            bufsize=8192
        )
        try:
            # Use wait() with a timeout to simplify the code
            process.wait(timeout=timeout_seconds)
        except subprocess.TimeoutExpired:
            process.kill()  # Terminate if timeout occurs
            print(f"LaTeX compilation for {output_figure_name} timed out.")
            return None
        if process.returncode != 0:
            raise subprocess.CalledProcessError(process.returncode, process.args)

        # Use PyMuPDF's memory-based operations
        pdf_data = open(os.path.join(temp_dir, 'temp.pdf'), 'rb').read()
        doc = fitz.open("pdf", pdf_data)
        page = doc.load_page(0)
        pixmap = page.get_pixmap(dpi=300)

        # Process image in memory
        img = Image.frombytes("RGB", [pixmap.width, pixmap.height], pixmap.samples)
        bg = Image.new(img.mode, img.size, (255, 255, 255))
        diff = ImageChops.difference(img, bg)
        bbox = diff.getbbox()

        if bbox:
            cropped_img = img.crop(bbox)
            # Store in buffer instead of writing to disk
            io_buffer.write(output_figure_name, cropped_img)
            return True
        return False

    finally:
        if os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)

def process_chunk(start_idx, chunk_data, output_dir, initial_offset=335000):
    """Process a chunk with optimized I/O operations"""
    process_start_time = datetime.now()
    process_id = mp.current_process().pid
    print(f"Process {process_id} started at {process_start_time.strftime('%Y-%m-%d %H:%M:%S')}")

    chunk_metadata = []
    chunk_errors = []
    io_buffer = IOBuffer()

    # Create thread pool for I/O operations
    with ThreadPoolExecutor(max_workers=4) as io_executor:
        for local_idx, tikz_code in enumerate(chunk_data):
            global_idx = start_idx + local_idx + initial_offset
            try:
                original_png_filename = f"original_{global_idx}"
                tikz_code = add_documentclass_if_missing(tikz_code)

                # Process original image
                future = io_executor.submit(
                    tikz2png_buffered,
                    tikz_code,
                    original_png_filename,
                    process_id,
                    io_buffer
                )

                if future.result(timeout=120) is None:
                    print(f"Skipping timed-out sample {global_idx}")
                    continue  # Skip to next iteration if original timed out

                tikz_samples = []
                sample_images = []
                sample_futures = []

                max_attempts = 6
                successful_samples = 0
                tries = 0


                # Process samples
                start_time = time.time()
                for i in range(4):
                    if successful_samples == 3:
                        break
                    try:
                        generated_code = main(tikz_code)

                        # Skip if generated code matches the original tikz_code
                        if generated_code == tikz_code:
                            continue

                        sample_png_filename = f"sample_{global_idx}_{successful_samples}"

                        # Submit sample processing to thread pool
                        future = io_executor.submit(
                            tikz2png_buffered,
                            generated_code,
                            sample_png_filename,
                            process_id,
                            io_buffer
                        )
                        if future.result(timeout=120):
                            successful_samples += 1
                            sample_futures.append((future, sample_png_filename, generated_code))
                    except Exception as e:
                        chunk_errors.append({
                            "error": f"Error in sample generation {global_idx}_{tries}: {str(e)}",
                            "tikz_code": tikz_code
                        })

                # Fallback logic if not enough successful samples
                for i in range(8):
                    if successful_samples == 3:
                        break
                    try:
                        generated_code = main(tikz_code, False)

                        # Skip if generated code matches the original tikz_code
                        if generated_code == tikz_code:
                            continue

                        sample_png_filename = f"sample_{global_idx}_{successful_samples}"

                        # Submit the attempt to the thread pool
                        future = io_executor.submit(
                            tikz2png_buffered,
                            generated_code,
                            sample_png_filename,
                            process_id,
                            io_buffer
                        )
                        if future.result(timeout=120):
                            successful_samples += 1
                            sample_futures.append((future, sample_png_filename, generated_code))

                    except Exception as e:
                        chunk_errors.append({
                            "error": f"Error in fallback sample generation {global_idx}: {str(e)}",
                            "tikz_code": tikz_code
                        })

                # Collect results from futures
                num = 0
                for future, filename, code in sample_futures:
                    try:
#                         if future.result(timeout=60):
                        tikz_samples.append(code)
                        sample_images.append(filename)
                        num += 1
                        if num == 3:
                            break
                    except Exception as e:
                        chunk_errors.append({
                            "error": f"Error processing sample {filename}: {str(e)}",
                            "tikz_code": code
                        })

                # Skip adding the sample if sample_images is empty
                if sample_images:
                    chunk_metadata.append({
                        "tikz_code": tikz_code,
                        "original_image": original_png_filename,
                        "generated_samples": tikz_samples,
                        "sample_images": sample_images
                    })
                if global_idx % 100 == 0:
                    print(f"{global_idx} is successful")

                # Periodically flush buffer to disk
                if len(io_buffer._buffer) >= 30:
#                     print(f"Flushing {len(io_buffer._buffer)} images")
                    io_buffer.flush_to_disk(output_dir)

            except Exception as e:
                chunk_errors.append({
                    "error": f"Error processing index {global_idx}: {str(e)}",
                    "tikz_code": tikz_code
                })
                continue

        # Final flush of remaining images
        print(f"Final flush of {len(io_buffer._buffer)} images")
        io_buffer.flush_to_disk(output_dir)

    process_end_time = datetime.now()
    print(f"Process {process_id} finished at {process_end_time.strftime('%Y-%m-%d %H:%M:%S')}")
    return chunk_metadata, chunk_errors


def save_metadata_to_parquet_fixed_size(metadata, output_dir, base_filename="tikz_sample", max_size_mb=500):
    """
    Saves metadata to multiple Parquet files, each with a maximum size of approximately max_size_mb.

    Args:
        metadata (list): List of dictionaries containing metadata to save.
        output_dir (str): Directory to save Parquet files.
        base_filename (str): Base name for Parquet files.
        max_size_mb (int): Maximum size per Parquet file in megabytes (default 500).
    """
    os.makedirs(output_dir, exist_ok=True)

    max_size_bytes = max_size_mb * 1024 * 1024  # Convert MB to bytes
    file_index = 73
    current_data = []

    def get_estimated_size(df):
        """Estimate the size of the DataFrame in bytes"""
        # Get size of DataFrame in memory
        df_size = df.memory_usage(deep=True).sum()
        # Add overhead for PyArrow conversion and Parquet formatting
        estimated_size = df_size * 1.2  # 20% overhead estimation
        return estimated_size

    def write_chunk(data, index):
        """Write the current chunk of data to a Parquet file"""
        if not data:
            return

        df = pd.DataFrame(data)
        table = pa.Table.from_pandas(df)
        file_path = os.path.join(output_dir, f"{base_filename}_{index}.parquet")
        pq.write_table(table, file_path)
        actual_size_mb = os.path.getsize(file_path) / (1024 * 1024)
        print(f"Saved {file_path} with {len(data)} rows. File size: {actual_size_mb:.2f} MB")

    for entry in metadata:
        current_data.append(entry)

        # Check size after every 1000 entries to avoid excessive checks
        if len(current_data) % 1000 == 0:
            df_temp = pd.DataFrame(current_data)
            estimated_size = get_estimated_size(df_temp)

            if estimated_size >= max_size_bytes:
                # If we're over the size limit, remove the last entry
                last_entry = current_data.pop()

                # Write current batch to a Parquet file
                write_chunk(current_data, file_index)

                # Start new batch with the last entry
                file_index += 1
                current_data = [last_entry]

    # Write any remaining data in the last file
    if current_data:
        write_chunk(current_data, file_index)

def main_parallel(max_samples=400):
    total_start_time = datetime.now()
    print(f"\nStarting processing at: {total_start_time.strftime('%Y-%m-%d %H:%M:%S')}")

    # Use RAM disk if available
    base_temp_dir = '/dev/shm/tikz_temp' if os.path.exists('/dev/shm') else './navid'
    os.makedirs(base_temp_dir, exist_ok=True)

    # Configure process pool
    num_cores = mp.cpu_count()
    num_processes = max(1, num_cores - 1)
    print(f"Using {num_processes} processes for computation")

#     test_dataset =
    dataset = load_dataset("Navidium/datikz-v2", data_files={"train": "train/*.arrow"})
    dataset = DatasetDict({
        "train": dataset["train"].select([i for i in range(dataset["train"].num_rows) if i != 408])
        })
    dataset_train = dataset['train']['code'][335000:350000]

    output_dir = "./tikz_samples"
    os.makedirs(output_dir, exist_ok=True)

    chunk_size = ceil(len(dataset_train) / num_processes)
    chunks = [dataset_train[i:i + chunk_size] for i in range(0, len(dataset_train), chunk_size)]
    chunk_args = [(i * chunk_size, chunk, output_dir) for i, chunk in enumerate(chunks)]

    pool = mp.Pool(processes=num_processes)
    results = []

    with tqdm(total=len(chunks), desc="Processing chunks") as pbar:
        for args in chunk_args:
            result = pool.apply_async(process_chunk,
                                      args=args,
                                      callback=lambda _: pbar.update(1))
            results.append(result)

        pool.close()
        pool.join()

    combined_metadata = []
    all_errors = []
    for result in results:
        chunk_metadata, chunk_errors = result.get()
        combined_metadata.extend(chunk_metadata)
        all_errors.extend(chunk_errors)

    # Read image as binary data instead of encoding
    def load_image_as_binary(image_path):
        with open(image_path, "rb") as img_file:
            return img_file.read()

    # Structure data for Parquet saving with binary images
    data_for_parquet = []
    # import pdb; pdb.set_trace()
    for item in combined_metadata:
        try:
            # Ensure the main tikz_code and original image are not empty
            if not item["tikz_code"]:
                continue  # Skip this item if the main tikz_code is empty

            # Generate a unique ID for the original image
            original_id = item["original_image"]
            original_image_path = os.path.join(output_dir, f"{original_id}.png")
            original_image_binary = load_image_as_binary(original_image_path)

            # Skip if the original image binary data is empty
            if not original_image_binary:
                continue

            # Store the original image in its own row
            # data_for_parquet.append({
            #     "original_id": original_id,
            #     "tikz_code": item["tikz_code"],
            #     "image": original_image_binary,
            #     "image_type": "original"
            # })

            # Add each sample image and link it to the original image using original_id
            for i, (sample_img, tikz_code) in enumerate(zip(item['sample_images'], item['generated_samples']), start=1):
                if not tikz_code:
                    continue

                sample_img_path = os.path.join(output_dir, f"{sample_img}.png")
                sample_image_binary = load_image_as_binary(sample_img_path)

                # Skip if the sample image binary data is empty
                if not sample_image_binary:
                    continue

                # Store each sample image in its own row, linked to the original image by original_id
                data_for_parquet.append({
                    "original_id": original_id,  # Link to the original image
                    "tikz_code": tikz_code,      # Use the specific tikz_code for this sample
                    "image": sample_image_binary,
                    "image_type": f"sample_{i}"
                })

        except Exception as e:
            print(f"Error processing item {item}: {e}")

    # Save to Parquet with file size limit
    # import pdb; pdb.set_trace()
    save_metadata_to_parquet_fixed_size(data_for_parquet, output_dir='./train', base_filename="data", max_size_mb=500)

    print("\nData successfully saved with a 500 MB limit on each Parquet file")

    # Optionally log errors
    if all_errors:
        with open("error_log.txt", "w") as f:
            for error in all_errors:
                f.write(f"Error: {error['error']}\nTikZ Code: {error['tikz_code']}\n\n")

    total_end_time = datetime.now()
    print("\nProcessing Summary:")
    print(f"Start time: {total_start_time.strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"End time: {total_end_time.strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Total duration: {total_end_time - total_start_time}")
    print(f"Processed {len(combined_metadata)} samples with {len(all_errors)} errors")

    if os.path.exists(base_temp_dir):
        shutil.rmtree(base_temp_dir)

if __name__ == '__main__':
    main_parallel(max_samples=400)


from huggingface_hub import HfApi, HfFolder, Repository
import os

# Set up API and login (ensure youâ€™re logged in with `huggingface-cli login`)
api = HfApi()
repo_name = "Navidium/tikz-v2"
image_folder = "./train"
# api.create_repo(repo_name, exist_ok=True, repo_type="dataset",)

api.upload_folder(
    folder_path=image_folder,
    path_in_repo=image_folder,
    repo_id=repo_name,
    repo_type="dataset",
)
